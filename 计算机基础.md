<!--
 * @Author: Zhanglei
 * @Date: 2022-01-18 21:32:11
 * @LastEditors: Zhanglei
 * @LastEditTime: 2022-02-11 19:29:46
 * @Description: file content
-->

# 计算机基础

## 进程、线程、协程
- 进程
  - 资源调度的基本单位

- 线程
  - 程序执行的基本单位，轻量级的进程
  - 启动快，开销小
  - 需要处理数据一致性问题
  - 同一进程内部有多个线程

- 协程
  - 用户态的轻量级线程，线程内部的调度单位

## 进程和线程比较
- 线程启动速度快，轻量级
- 线程的系统开销小
- 线程使用有一定难度，需要处理数据一致性问题
- 同一线程共享的有堆、全局变量、静态变量、指针，引用、文件等，而独自占有栈

## 一个进程可以创建多少线程
- 理论上进程的虚拟空间为2G，线程大小为1MB，可以创建2048个
- 由可用的虚拟空间和线程大小决定数量

## 外中断和异常的区别
- 外中断由CPU执行指令外的事件引起，比如输入结束、控制台中断
- 异常是由CPU执行指令引起的，比如数据溢出、地址越界等
  
## 进程模型
- Linux进程控制
  - 进程地址空间
  - 进程控制块，内核调度实际是选择进程控制块，记录进程信息
  - 通过上下文切换


## 进程调度算法
- 先来先服务 first-come first-serverd（FCFS）
  - 按照请求顺序进行调度
  - 适合长作业，不适合短作业，短作业会由于长作业长时间占用等待时间过长
- 短作业优先 shortest job first（SJF）
  - 按照运行时间顺序进行调度
  - 但长作业会因为短作业不停到来等待时间过长
- 最短剩余时间优先 shortest remaining time next（SRTN）
  - 新的请求与正在运行的请求做比较，剩余时间长的进程挂起
- 时间片轮转
  - 进程按照FCFS排列
  - 分配时间片，时间片用完，进程排到队尾，给队首进程继续分配时间片
  - 效率与时间片大小有关

- 优先级调度

- 多级反馈队列

## 线程锁
- 互斥锁
  - 任何时刻只有一个线程访问该资源，获取锁失败时，线程进入阻塞状态
- 读写锁
  - 读可以有多个线程，写只能是一个线程
- 自旋锁
  - 任何时刻只有一个线程访问该资源，获取锁失败时，线程原地自旋，直至锁被释放
- 条件变量
  - 满足条件才被唤醒，否则处于阻塞状态
- 信号量

## Linux进程间通信方式

- 管道
  - 无名管道
    - 内存文件形式
    - 数据单向流通，只能在父子进程之间使用
  - 有名管道
    - 借助文件系统，能够在没有亲缘关系的进程之间使用
    - 遵循FIFO原则

- 共享内存
  - 映射一段能够被其他进程访问的内存
  - 效率高，与信号量配合使用实现进程同步与通信

- 信号
  - 用于通知进程某个事件已经发生，比如ctrl+c
- 信号量
  - 计数器，用于控制多个进程对共享资源的互斥访问

- 套接字
  - 适用不同机器之间的进程通信，也可用于同一机器的两个进程

- 消息队列
  - 消息的链表，存放在内核中由消息队列标识符标识
  - 克服信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。

## Linux下的同步机制

- POSIX信号量
  - 可以用于进程、线程同步

- POSIX互斥锁+条件变量
  - 只能用于线程同步

## 进程状态切换
- 就绪态：等待被调度
- 运行态
- 阻塞态：等待资源

## 多线程和多进程
- 区别
- 线程私有数据
  - 栈
  - 状态
  - 寄存器
  - 程序计数器
- 共享数据
  - 全局变量
  - 堆上的数据
  - 函数的静态变量
  - 程序代码
  - 打开的文件

- pthread和tthread

## TCP
- 建立连接的过程：三次握手，客户端和服务端总共发送三个包，为了确认双方的接收和发送能力是否正常
- 实质上是连接服务器的指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换 **TCP窗口大小**信息。
  - 初始状态：客户端closed，服务端listen状态
  - 第一次握手：客户端发送一个SYN报文，客户端处于SYN_SEND状态
  - 第二次握手：服务端接收到SYN报文，作应答把客户端ISN+1作为ACK值回复，服务器处于SYN_RCVD状态
  - 第三次握手：客户端接收到SYN报文，把服务端的ISN+1作为ACK值发送，此时双方处于ESTABLISHED状态

- 终止连接的过程：四次挥手，
  - 初始状态：都处于连接状态
  - 第一次挥手：客户端或者服务端发起，因为TCP全双工
  - 第二次挥手：服务端接收到释放请求后，发送ACK=1到客户端，服务端此时处于CLOSE_WAIT状态
  - 第三次挥手：服务端发送数据完毕，发送FIN=1到客户端，告诉客户端已发完数据，客户端可以关闭接收连接，此时服务端处于LAST_ACK状态
  - 第四次挥手：客户端收到服务端发送的消息，客户端进入TIME_WAIT状态，发送ACK=1，告诉服务端已收到信息，有2MSL延迟关闭，为了让最后这个ACK能够确保收到


## 四种IO模型
- 阻塞： 阻塞调用是指调用返回之前，当前线程会被挂起，只有当调用得到结果后才返回。
- 非阻塞：与阻塞相反，非阻塞调用是指在不能立即得到结果之前，该函数不会将当前线程阻塞，而是立即返回。
- 同步：所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回。等前一件做完了才能做下一件事。
- 异步：异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。


底层core