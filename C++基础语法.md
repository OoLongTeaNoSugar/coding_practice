<!--
 * @Author: Zhanglei
 * @Date: 2021-12-25 15:48:16
 * @LastEditors: Zhanglei
 * @LastEditTime: 2022-01-28 15:07:37
 * @Description: file content
-->

# C++整理
## 基础语法问题

- 1、指针和引用

- 2、堆和栈

- 3、`new/delete` 和 `malloc/free`
  - new分配内存失败抛出异常，malloc直接返回null
  - new分配内存是动态计算的，在自由储存区分配；而malloc需要指定大小，在堆上分配内存
  - new/delete是运算符，可以重载；malloc/free是C标准库函数，不允许重载
  - new/delete 封装了 malloc/free，除了分配/释放内存外，还会调用构造/析构函数
  - 前者返回定义时的指针类型，后者返回void类型指针

- free回收的内存如何处理
  - free的内存会被`ptmalloc`使用双链表保护起来，
  下次申请内存时，尝试从中选取合适的返回，
  避免了频繁系统调用占用过多的系统资源。

- 宏定义
  - 编译时完成转换，替换的文本直接参加编译
    运行时不存在调用，所以执行更快
  - 不进行类型检查
- typedef
  - 用于定义类型别名
  - 属于编译的一部分
  - 会进行类型检查
  
- 4、浅拷贝和深拷贝
  - 浅拷贝
    - 只拷贝一个指针，不开辟新地址，指向与之前相同的地址
    - 如果原来指针释放，会出现指针悬空错误
  - 深拷贝
    - 开辟新的空间存放新的值
    - 原先对象即使被析构，不影响现有对象

- 5、值传递、指针传递、引用传递
  - 值传递（传值）
    - 形参向函数栈拷贝数据过程，
    - 如果对象是类或者大的结构体，会耗费一定空间和时间
  - 指针传递（传地址值）
    - 同样有一个向函数栈拷贝的过程
    - 拷贝的是固定4字节的地址
  - 引用传递（传地址）
    - 针对地址拷贝，为其数据所在地址取了别名

- 6、三大特性
  - 继承
    - 让某种类型对象获得另一类型对象的属性和方法
    - 实现继承
    - 接口继承
    - 可视继承
  - 封装
    - 数据和代码封装在一起，避免外部干扰
  - 多态
    - 不同对象在接受同一消息时产生不同行为
    - 允许将子类型的指针赋值给父类指针
    - 重载overload和重写 override

- 7、成员初始列表为什么效率高
  - 赋值初始化，先分配空间再进行赋值
  - 列表初始化，分配空间时进行初始化
  - 减少一次调用构造函数的过程

- 8、C++四种强制转换类型
  - reinterpret_cast<type_id>(expression)
    - type_id 必须是指针、引用。。。
  - const_cast(expression)
    - 用于修改类型的const或volatile属性
  - static_cast<type_id>(expression)
    - 用于将expression转为type_id类型
    - 不能保证安全性
  - dynamic_cast
    - 有类型检查
    - 下行转换是安全的

- strlen 和 sizeof 的区别
  - sizeof 
    - 运算符，结果在编译阶段获得
    - 参数不退化，即参数可以时任何数据类型
    - 不能用来计算动态分配的空间大小
  - strlen
    - 字符处理的库函数，运行时获得结果
    - 参数只能是字符指针且结尾是`\0`的字符串

- 一个指针占用字节数量
  - 64位 8 字节； 32位 4字节

- 常量指针和指针常量
  - 指针常量
    - 是读成常量的指针，指向只读变量
    - `int const`  `const int`
  - 常量指针
    - 一个不能改变指向的指针，该指针是常量
    - 必须初始化，初始化完成就不能更改
    - `int *const p`

- struct 和 class 的区别
  - 都有成员函数、公有、私有部分
  - struct默认公有，class默认私有
  - class默认私有继承，struct默认公有继承

- static和const

- 野指针和悬空指针
  - 野指针
    - 指针变量未及时初始化
    - 定义时及时初始化或者置空
  - 悬空指针
    - 指针free或者delete后没有及时置空
    - 释放操作后立即置空

- 重载和重写
  - 重载
    - 函数名相同，参数类型、数目不同
  - 重写
    - 在派生类的基础上重写基类同名函数
    - 基类函数必须时虚函数
    - 重写的函数必须与虚函数有相同的参数个数、类型、返回类型

- 构造函数
  - 默认构造函数，没有参数
  - 初始化构造函数，有参数、参数列表
  - 拷贝构造，参数是同类型
  - 转换构造函数，形参是其他类型的变量，且只有一个形参

- 函数调用压栈过程
  - 1、从栈上分配空间
  - 2、从实参的储存空间赋值到形参的栈空间
  - 3、进行运算

- 全局变量和局部变量的区别
  - 生命周期不同
    - 全局变量按照主程创建和销毁
    - 局部变量被分配在堆栈上，在函数推出时销毁
  - 使用方式不同
    - 程序各个部分都可以使用全局变量
    - 局部变量在函数内部使用

- printf函数原理

- strcpy函数和strncpy函数
  - 函数原型
    - `char* strcpy(char* strDest, const char* strSrc)`
    - `char* strncpy(char* strDest, const char* strSrc, int pos)`
  - strcpy函数
    - 如果dest的内存空间不够，会造成缓存溢出
    - strncpy使用pos复制前n个字符

- 典型锁
  - 读写锁
    - 多个读者可以同时读取
    - 写者必须互斥
    - 写者优于读者，写者操作时，读者必须等待
  - 互斥锁
    - 一次一个线程有互斥锁，其他线程必须等待
    - 抢锁失败，主动放弃CPU进入睡眠状态
  - 条件变量
    - 允许线程阻塞和等待另一个线程发送信号
    - 和互斥锁一起使用
  - 自旋锁
    - 无法取得锁，线程不放弃CPU，一直尝试循环获取锁
    - 主要用于加锁时间短的场景
## C++11新特性

- 类型推导 
  - `auto`
    - 需要马上初始化，否则无法推导类型
  - `decltype`
    - 用于推导表达式的类型

- 右值引用
  - 将亡值
  - 左值引用
  - 右值引用
  - 移动语义

- nullptr
  - 为了区分空指针和0值

- 范围for循环
  - `for(auto &i : arr)`

- 列表初始化
  - 隐式转换时数据存在丢失风险时，编译错误

-  lambda表达式

- 并发

- 智能指针
  - C++11中为解决指针对象未及时释放造成的内存泄漏问题提出的
  - 用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。
  - `shared_ptr`
    - 原理机制
    - 缺陷
    - 如何解决
  - `weak_ptr`
    - 原理
    - 解决的问题
  - `unique_ptr`
  - `auto_ptr`
    - 解决“因抛出异常导致无法正常释放内存”的问题


## STL

- 什么是STL？
  - 算法
    - 排序、复制等常用算法
  - 容器
    - 序列式 vector，list
    - 关联式 map，set
  - 迭代器 
    - 对容器内部遍历

- vector
  - resize 和 reverse的区别
- list
  - 双向链表
  - 支持在`front`和`back`两个方向进行操作
- deque
  - 双端队列
- stack
  - 先进先出的数据结构
  - container adapter（配接器）：修改某种接口，形成另一种风貌的行为
  - stack使用deque作为底层容器进行改造
- queue
  - 先进先出的数据结构
  - container adapter
- heap
  - 作为priority queue的底层实现机制

- priority_queue
  - 底层：vector + max_heap
  - 默认最大根堆
- map
  - 基于红黑树，查询维护复杂度均为O(logN)
  - 但是空间占用大
  - 适用于有序数据的应用场景
- unordered_map
  - 底层是哈希表，查询复杂度O(1)
  - 但建立哈希表时间长
  - 适用于高效查询的场景
- set
- 红黑树
  - 二叉排序树
    - 左子树不为空，则左子树的所有结点值小于等于根节点
    - 右子树不为空，则右子树的所有节点值大于等于根节点
    - 左右子树也是二叉排序树
  - 满足以下条件
    - 所有节点非黑即红
    - 根节点必为黑
    - 红节点的子节点必为黑，但黑节点的子节点可以为黑
    - 从根到NULL的任何路径上的黑节点数量相同
  - 查找时间可以控制在O(logn)

- 哈希冲突解决方法
  - 线性探测
    - 向后找到空位插入
  - 开链
    - 维护一个节点list，冲突的元素接在该节点的最后
    - 当list过长时应该考虑扩容
  - 再散列
    - 发生冲突时用其他函数hash
## 内存管理

- 类的对象储存空间

- C++内存分区（从高到低）
  - 栈
    - 储存局部变量、函数参数
    - 效率高但容量有限
  - 堆
    - 动态申请存用，就是new分配的内存
  - 自由储存区
    - 介于堆、栈之间
  - 全局/静态储存区
    - 存放全局变量和静态变量
  - 常量储存区
    - 放置常量数据，不允许修改
  - 代码区
    - 存放执行代码的二进制代码



