- [动态规划整理](#动态规划整理)
  - [eg.1 斐波那契数列](#eg1-斐波那契数列)
    - [1.暴力递归](#1暴力递归)
    - [2.DP迭代方法](#2dp迭代方法)
  - [eg2.凑零钱问题](#eg2凑零钱问题)

# 动态规划整理

- 动态规划的特点：
  1. 一定是可枚举的**求最值** 问题，具有重叠子问题
  2. 具有最优子结构，即最小子问题求解最值
  3. 可列出**状态转移方程**
- 状态转移方程：
  - 过程：**明确base case -> 明确【状态】-> 明确【选择】-> 定义dp表的含义**
```cpp
//base case
dp[0][0] = base case
//状态转移
for 状态1 in 状态列表:
    for 状态2 in 状态列表2:
        ....
        dp[状态1][状态2] = 求最值（）....
```

## eg.1 斐波那契数列

### 1.暴力递归

最原始的方法：
```cpp
int fib(int n){
    if(n == 1 || n == 2) return 1;
    return fib(n-1) + fib(n-2);
}
```

子问题数量为$O(2^n)$，子问题为加法，时间为$O(1)$，故暴力递归的时间总复杂度为数量乘以时间，$O(2^n)$。

画二叉树，其中发现大量重复计算的子问题，可以用demo记录成HashMap，避免重复计算，也即DP表。

### 2.DP迭代方法

通过观察发现，
$$f(n) = f(n-1) + f(n-2)$$
f(n)的状态只与f(n-2)、f(n-1)有关，**自底向上**推出$f(n)$的结果。

$$ f(n) = \begin{cases}
    1, & \text{if n = 1,2, base case}\\
    f(n-1)+f(n-2) & \text{if n >2}
\end{cases}
$$

## eg2.凑零钱问题



[返回README](README.md)